\documentclass{article}

\input{imports}

\begin{document}

\title{DPP Assignment 2}
\author{Cornelius Sevald-Krause \\ \texttt{<lgx292>}}
\date{2022-12-09}
\maketitle

\section*{Task 1}

All code can be found in the \verb|src.zip| archive. To compile the code,
run \verb|make| in the \verb|ispc-handout/| folder. To benchmark the programs,
run \verb|make run| instead.

All benchmarks were done on the \verb|gpu04-diku-apl| machine with the
\verb|sse4| target. I've also added the \verb|--pic| flag to the
\verb|ispc| compiler and \verb|-fPIC| flag to \verb|CFLAGS|. I don't think they
have any real impact on preformance but i could not use the \verb|ispc print|
function otherwise.

All benchmarks were done over 10000 runs by changing the \verb|num_runs|
variable in \verb|timing.h|.

\subsection*{Prefix sum}

\noindent
The ISPC program is shown in~\cref{lst:scan}.

The idea is to use \verb|exclusive_scan_add| and manually add the \verb|x| value
to make it and inclusive scan. Then, the scanned value of the final program is
broadcasted to all others and added to \verb|acc|.

The results of the benchmarks are shown below:
\begin{Verbatim}
C:      91 microseconds
ISPC:   50 microseconds
\end{Verbatim}
The ISPC version has a speedup of \textapprox 1.82x.

\subsection*{Removing neighboring duplicates}

\noindent
The ISPC program is shown in~\cref{lst:pack}.

The program uses \verb|rotate| to compare neighboring elements and makes sure
the element of the first program is compared with the final element of the last
iteration (\verb|cur|) via \verb|insert|. To make sure that \verb|cur| is
distinct in the very first iteration, it initialized to the first input values
XOR'ed with 1. The program avoids conditional writes just like the optimized
\verb|filter| program.

The results of the benchmarks are shown below:
\begin{Verbatim}
C:      404 microseconds
ISPC:   168 microseconds
\end{Verbatim}
The ISPC version has a speedup of \textapprox 2.4x.

\subsection*{Run-length encoding}

\noindent
The ISPC program is shown in~\cref{lst:rle}.

The program has two cases. Either all elements are the same in which case
\verb|count| is increased by one for each element. In the case where not all
elements are the same, we loop over each program in the gang and essentially
just do as the sequential C program does. Finally we remember to write the final
value and count after the final iteration.

The results of the benchmarks are shown below:
\begin{Verbatim}
C:      75 microseconds
ISPC:   44 microseconds
\end{Verbatim}
The ISPC version has a speedup of \textapprox 1.7x.

\begin{listing}[p]
    \centering
    \inputminted{c}{../ispc-handout/scan.ispc}
    \caption{\texttt{scan.iscp} program.}
    \label{lst:scan}
\end{listing}
\begin{listing}[p]
    \centering
    \inputminted{c}{../ispc-handout/pack.ispc}
    \caption{\texttt{pack.iscp} program.}
    \label{lst:pack}
\end{listing}
\begin{listing}[p]
    \centering
    \inputminted{c}{../ispc-handout/rle.ispc}
    \caption{\texttt{rle.iscp} program.}
    \label{lst:rle}
\end{listing}

\FloatBarrier

\section*{Task 2}

Let $H = (max^s) \times h_2 \times h_3 \times h_4$ where $h_2 , h_3 , h_4$ are
to be determined. We also need to determine $\otimes'_1 , \otimes'_2 ,
\otimes'_3$ and $\otimes'_4$.

First we need to show that the following is true:

\begin{equation}\label{eq:max_cross}
    max^s\ (xs \crossop_{+} ys) = max\ xs + max\ ys
\end{equation}
where $max$ is defined as $max^s$ but over lists instead of sets.

\begin{proof}
    From the definition of $\crossop_{\oplus}$ and $max^s$ we have
    \[
        max^s\ \left(
            [x_1, \ldots, x_n] \crossop_{+} [y_1, \ldots, y_m]
        \right) = x_i + y_j
    \]
    where $1 \leq i \leq n$ and $1 \leq j \leq m$ are chosen such that they
    maximize $x_i + y_j$. As maximizing a sum of two numbers is the same as
    maximizing the two individual numbers, we can conclude that
    $x_i = max\ [x_1, \ldots, x_n]$ and $y_j = max\ [y_1, \ldots, y_m]$.
    Substituting $x_i$ and $y_j$ in the formula above we get
    $max^s\ (xs \crossop_{+} ys) = max\ xs + max\ ys$.
\end{proof}

We can now derive $H$ and $\otimes'_1 , \otimes'_2 , \otimes'_3 , \otimes'_4$.
We start with $\otimes'_1$:
\begin{align*}
      & max^s\ ((s_1,i_1,t_1,d_1) \otimes_1 (s_2,i_2,t_2,d_2))          \\
    = & \quad \{\ \text{Def. of $\otimes_1$}\ \}                        \\
      & max^s\ (s_1 \cup s_2 \cup (t_1 \crossop_{+} i_2))                \\
    = & \quad \{\ \text{Def. of $max^s$}\ \}                            \\
      & max^s\ s_1 \maxop mas^s s_2 \maxop max^s\ (t_1 \crossop_{+} i_2) \\
    = & \quad \{\ \eqref{eq:max_cross}\ \}                              \\
      & max^s\ s_1 \maxop mas^s s_2 \maxop max\ t_1 + max\ i_2          \\
\end{align*}
Matching the last part with:
\[
    (max^s\ s_1, h_2\ i_1, h_3\ t_1, h_4\ d_1) \otimes'_1
    (max^s\ s_2, h_2\ i_2, h_3\ t_2, h_4\ d_2)
\]
gives
\begin{align*}
    & h_2 = h_3 = max \\
    & (s_1, i_1, t_1, d_1) \otimes'_1
      (s_2, i_2, t_2, d_2)
    = s_1 \maxop s_2 \maxop (t_1 + i_2)
\end{align*}

We now derive $\otimes'_2$:
\begin{align*}
      & max\ ((s_1,i_1,t_1,d_1) \otimes_2 (s_2,i_2,t_2,d_2))    \\
    = & \quad \{\ \text{Def. of $\otimes_2$}\ \}                \\
      & max\ (i_1 \concat (d_1 +) \map i_2)                     \\
    = & \quad \{\ \text{Def. of $max$}\ \}                      \\
      & max\ i_1 \maxop max\ ((d_1 +) \map i_2)                 \\
    = & \quad \{\ \text{
            $max\ (f \map xs) = f\ (max\ xs)$
            for non-decreasing $f$
        }\ \}                                                   \\
      & max\ i_1 \maxop (d_1 + max\ i_2)                        \\
    = & \quad \{\ \text{Def. of $id$}\ \}                       \\
      & max\ i_1 \maxop (id\ d_1 + max\ i_2)                    \\
\end{align*}
Matching the last part with:
\[
    (max^s\ s_1, h_2\ i_1, h_3\ t_1, h_4\ d_1) \otimes'_2
    (max^s\ s_2, h_2\ i_2, h_3\ t_2, h_4\ d_2)
\]
gives
\begin{align*}
    & h_2 = max \\
    & h_4 = id  \\
    & (s_1, i_1, t_1, d_1) \otimes'_2
      (s_2, i_2, t_2, d_2)
    = i_1 \maxop (d_1 + i_2)
\end{align*}
We have now derived $H = (max^s) \times (max) \times (max) \times (id)$.
We won't show the derivation of $\otimes'_3$ and $\otimes'_4$ but their
definitions are shown below:

\begin{align*}
    (s_1, i_1, t_1, d_1)
    \otimes'_3
    (s_2, i_2, t_2, d_2)
    &= (d_2 + t_1) \maxop t_2   \\
    (s_1, i_1, t_1, d_1)
    \otimes'_4
    (s_2, i_2, t_2, d_2)
    &= d_1 + d_2                \\
\end{align*}

Finally, we show that $h_j \compose f'_j = id$ for $j = 1, \ldots , 4$:
\begin{alignat*}{2}
    (h_1 \compose f_1)\ x &= max^s\ \{ x \} \ &= x \\
    (h_2 \compose f_2)\ x &= max\     [x]   \ &= x \\
    (h_3 \compose f_3)\ x &= max\     [x]   \ &= x \\
    (h_4 \compose f_4)\ x &= id\       x    \ &= x \\
\end{alignat*}

\end{document}
